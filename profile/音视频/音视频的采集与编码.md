
## 音视频的采集与编码


#### 音频的采集

    MediaRecorder，上层的API
    AudioRecord，更加接近底层
    OpenSL ES，native层接口
    将PCM数据编码为AAC或者MP3文件
    RECORD_AUDIO 权限，文件权限

    AudioRecord工作流程：
        1、配置参数，初始化内部的音频缓冲区，new AudioRecord()
            bufferSizeInBytes，音频缓冲区大小，该缓冲区越小，产生的延时就会越小，getMinBufferSize获取
            查看当前状态，getState是否是AudioRecord.STATE_INITAILIZED
        2、开始采集，startRecording()
        3、提取数据，read，从缓冲区及时将音频数据取出来（子线程）
        4、保存数据
        5、停止采集，释放资源，最后关闭写入数据的文件
            stop、release

#### 视频画面的采集

    摄像头API
    CAMERA权限
    配置摄像头参数，预览格式一般设置为NV21格式，它实际上就是YUV420SP的格式
    设置预览尺寸，分辨率的尺寸一般设置为 1280X720
    摄像头默认采集出来的视频画面是横板的，显示的时候需要获取当前摄像头采集出来的画面的旋转角度：
        if(FRONT)
            degrees = CameraInfo.orientation % 360;
        else if (BACK)
            degrees = (CameraInfo.orientation + 360) % 360;
    摄像头的预览：
        OpenGL ES渲染图像，先把图像解码为RGBA格式，然后将RGBA格式的字节数组上传到一个纹理上，最终将纹理渲染到屏幕上
        预览过程：开始预览、刷新预览、结束预览
        surfaceTexture = new SurfaceTexture(textureId)  //textureId，纹理ID，从Native层传到Java层
        camera.setPreviewTexture(surfaceTexture)
        surfaceTexture.setOnFrameAvailableListener()
        camera.startPreview()
        绑定纹理时使用：
            glBindTexture(GL_TEXTURE_EXTERNAL_OES, texId)，而不是GL_TEXTURE_2D
        对纹理设置参数时也要使用GL_TEXTURE_EXTERNAL_OES
        fragment shader中声明扩展：
            #extension GL_OES_EGL_image_external : require，放在第一行

        预览角度调整，具体计算见 P144
        将一个特殊格式（OES）的纹理ID经过处理和旋转，使其变成正常格式（RGBA）
        涉及的计算见 P145
        项目 CameraPreview

#### 音频的编码


## 视频录制器

#### 架构设计

    将声音和画面全部录制下来，生成一个MP4文件，以及是否需要开启背景音乐
    音频：
    Input模块，麦克风输入来采集声音、伴奏输入-伴奏文件解码器（解码背景音乐）；播放音乐、录音
    Output模块，利用渲染音频的API播放背景音乐（以及耳返）、记录数据，将背景音乐和用户声音的数据保存
    PCM队列模块，把背景音乐和用户的声音的PCM数据存入队列中，多线程安全；Blocking Queue
    Consumer模块，负责从队列取出PCM数据，进行音频AAC编码，最终封装到MP4文件中；Mix成一轨音频数据，使用FFmpeg的Muxer模块封装
    视频：
    Input模块，使用Camera API
    Output模块，预览（OpenGL+SurfaceView实现）、编码（优先硬件编码，libx264软件编码），最终编码为H264数据
    H264队列模块，线程安全的链表
    Consumer模块，取出队列中的H264数据包，利用FFmpeg的Mux模块封装到MP4的视频轨道中

    风险分析：硬件编码器的兼容性，软件编码器的性能问题，音视频同步问题

#### 音频模块的实现

    如何将采集的数据放入队列，以及如何播放背景音乐
    音频队列的实现：
        typedef struct AudioPacket {
            short *buffer;
            int size;
            AudioPacket() {
                buffer = NULL;
                size = 0;
            }
            ~AudioPacket() {
                if(NULL != buffer) {
                    delete[] buffer;
                    buffer = NULL;
                }
            }
        } AudioPacket;
        每采集一段时间的PCM音频数据就封装成AudioPacket结构体对象，放入到PCM队列
        typedef struct AudioPacketList {
            AudioPacket *pkt;
            struct AudioPacketList *next;
            AudioPacketList() {
                pkt = NULL;
                next = NULL;
            }
        } AudioPacketList;
        队列需要考虑线程安全，加锁，表头和表尾
        int put(AudioPacket *pkt) {
            if(aborted) {
                delete pkt;
                return -1;
            }
            AudioPacketList *pkt1 = new AudioPacketList();
            if(!pkt1)
                return -1;
            pkt1->pkt = pkt;
            pkt1->next = NULL;
            pthread_mutex_lock(&lock);
            if(mLast == NULL)
                mFirst = pkt1;
            else
                mLast->next = pkt1;
            mLast = pkt1;
            pthread_cond_signal(&cond);
            pthread_mutex_unlock(&lock);
            return 0;
        }
        取数据时，从表头开始，空时阻塞
        int get(AudioPacket **pkt) {
            AudioPacketList *pkt1;
            int ret = 0;
            pthread_mutex_lock(&lock);
            for(;;) {
                if(aborted) {
                    ret = -1;
                    break;
                }
                pkt1 = mFirst;
                if(pkt1) {
                    mFirst = pkt1->next;
                    if(!mFirst)
                        mLast = NULL;
                    mNbPackets--;
                    *pkt = pkt1->pkt;
                    delete pkt1;
                    pkt1 = NULL;
                    ret = -1;
                } else {
                    pthread_cond_wait(&cond, &lock);
                }
            }
            pthread_mutex_unlock(&lock);
            return ret;
        }
        abort方法，将aborted设置为true，同时发送一个signal指令，防止线程被block
        销毁方法，遍历队列中所有的元素，然后释放它们

    Input模块：
## Effective Java

    清晰性和简洁性最为重要
    模块要尽可能小
    代码应该被重用，而不是被拷贝
    模块之间的依赖性应该尽可能地降到最小
    错误应该尽早被检测出来，最好是在编译阶段

#### 创建和销毁对象

    何时如何创建对象，何时如何避免创建对象
    如何确保对象能够适时地销毁，如何管理对象销毁之前必须进行的清理动作

    1、考虑用静态工厂方法代替构造器：
        类提供公有的静态工厂方法（只是一个返回类实例的静态方法）
        工厂方法有名称，可以通过不同的名称创建不同的实例
        不必在每次调用时都创建一个新对象（单例，不可变类），实例受控
        可以返回原返回类型的任何子类型的对象（子类，多态）
        在创建参数化类型实例的时候，使代码变得更加简洁
        类如果不含public或者protected的构造器，就不能被子类化
        静态工厂方法的惯用名称：
            valueOf，返回实例与其参数有相同的值，它实际上是类型转换方法
            of，valueOf 的更简洁的替代
            getInstance，返回实例是通过方法的参数来描述的，没有参数一般返回单例，唯一实例
            newInstance，每次都返回新的实例
            getType，像getInstance一样，Type表示返回的对象类型，方法处于不同的类中时使用
            newType，像newInstance一样，Type表示返回的对象类型
        静态工厂方法优于公有构造器，一般先考虑静态工厂

    2、遇到多个构造器参数时要考虑用构建器（Builder模式）：
        抛弃重叠构造器模式，适用多参数的情况
        不可变类优先（final）
        builder对入参做约束检查
        builder一般是它要构建的类的静态成员类
        在4个或更多个参数时使用（多个可选参数的场景）

    3、用私有构造器或者枚举类型强化Singleton属性：
        单例，指仅仅被实例化一次的类
        使构造器保持私有，提供公有的静态成员或静态方法等
        枚举实现单例（提供序列化机制，实现单例的最佳方法）：
            public enum Singleton {
                INSTANCE;
                ...
            }
        非枚举的单例，实现序列化时，必须声明所有实例域（变量）都是（transient 修饰），并提供一个readResolve方法：
            private Object readResolve() {
                return INSTANCE;    //该方法在反序列化时被调用
            }

    4、通过私有构造器强化不可实例化的能力：
        让类包含私有构造器，它就不能被实例化
        private Util() {
            throw new AssertionError();
        }
        使类不能被子类化，适用于工具类

    5、避免创建不必要的对象：
        最好能重用对象而不是在每次需要时就创建一个相同功能的新对象
        重用不可变类（immutable）
        重用那些已知不会被修改的可变对象
        注意自动装箱，优先使用基本类型
        小对象的创建和回收动作是非常廉价的，可通过创建附加对象，提升程序清晰性、简洁性和功能性
        通过维护对象池来避免创建对象并不是好做法，除非对象池中的对象是非常重量级的

    6、消除过期的对象引用：
        内存泄漏
        过期引用，指永远不会再被解除的引用，对过期引用要及时置null
        只要类是自己管理内存，就应该警惕内存泄漏的问题
        缓存，内存泄漏的另一个常见来源；WeakHashMap（只有当所要缓存项的生命周期是该键的外部引用而不是由值决定时使用）
        LinkedHashMap，LRU算法，缓存
        内存泄漏的常见来源3：监听器和其他回调，使用弱引用
        Heap剖析工具（Heap Profiler）分析内存泄漏问题

    7、避免使用终结方法：
        finalizer通常是不可预测的，也是很危险的
        使用终结方法会导致行为不稳定、降低性能以及可移植性问题
        终结方法的缺点在于不能保证会被及时地执行
        不应该依赖终结方法来更新重要的持久状态
        提供一个显式的终止方法去释放资源
        显式的终止方法通常与try-finally结构结合使用，以确保及时终止
        终结方法的好处：充当安全网，兜底（日志记录非法用法），eg--FileInputStream等
        若子类覆盖了终结方法，子类的终结方法中必须手动调用超类的终结方法（super.finalize()，try-finally中确保必须调用）
        终结方法守卫者（finalizer guardian）：把终结方法放在匿名类中，该匿名类被用于终结它的外围类实例
            private final Object finalizerGuardian = new Object() {
                protected void finalize() {
                    //调用外围类的终结方法，终止方法，防止子类不调用超类的终结方法
                }
            }
        若无必要，不使用终结方法，除非作为安全网、或为终止非关键本地资源，子类必须调用super.finalize，或使用终结方法守卫者

#### 对于所有对象都通用的方法

    Object中所有非final方法都有明确的通用约定

    8、覆盖equals时请遵守通用约定

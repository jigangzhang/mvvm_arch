
## 多线程

[参考](https://mp.weixin.qq.com/s/NKMK764xHmEFKP_JyT-t_w)
    
    join、wait、notify
    concurrent包（JUC）、各种锁
    线程是进程中可独立执行的最小单元，也是CPU资源分配的基本单元，CPU资源就是CPU时间片（资源是分配给线程的）
    进程是向OS申请资源的基本条件，一个进程可以包含多个线程，同一个进程中的线程可以共享进程中的资源，内存空间、文件句柄等

#### 线程的4个属性

        编号，线程的编号（id），用来标识线程，不能作为唯一标识，只读（不能修改）
        名字，默认值是Thread-线程编号，也可以自己设置名字，区分线程
        类别，分为守护线程和用户线程，setDaemon(true)把线程设置为守护线程（线程启动前设置），JVM退出时会考虑用户线程是否执行完毕，不会考虑守护线程
        优先级，Priority，用于表示希望优先运行哪个线程，线程调度器会根据这个值来决定优先运行哪个，取值范围1~10，默认是5，1最低，10最高，不保证一定会按优先顺序执行，优先级使用不当会导致某些线程无法执行，即线程饥饿
    线程的类别和优先级是会被继承的，初始值由开启改线程的线程决定

#### 线程的6个方法

        start，启动线程，只能调用一次
        run，任务的具体逻辑，由JVM调用
        join，用于等待其他线程执行结束，线程A调用线程B的join方法，那线程A会进入等待状态，直到线程B运行结束；join的等待状态是可以被中断的（需要捕获中断异常）
        currentThread，静态方法，用于获取当前线程，以设置名字、优先级等
        yield，静态方法，用于使当前线程放弃对CPU的占用，该方法不一定会让线程进入暂停状态
        sleep，静态方法，使当前线程在指定时间内休眠（暂停）

#### 线程的6种状态
        <br><img src="线程的生命周期.jpg" width="500" height="300"/><br>
        通过Thread.getState获取线程的状态
        新建状态（NEW），线程创建后未启动时，就处于新建（NEW）状态
        可运行状态（RUNNABLE），调用start后，线程就进入了可运行状态；可运行又分为预备和运行状态：
            预备状态（READY），这个状态的线程可被线程调度器调度，调度后线程状态从预备转换为运行状态，预备状态的线程也叫活跃线程
            运行状态（RUNNING），表示线程正在运行，处理器正在执行run方法，yield后，线程状态可能由运行状态变为预备状态
        阻塞状态（BLOCKED），发起阻塞式IO操作、申请其他线程持有的锁、进入同步方法等时会处于该状态
        等待状态（WAITING），Object.wait、LockSupport.park、Thread.join 可以让线程进入等待状态；Object.notify/notifyAll、LockSupport.unpark 可以让线程从等待状态转变为可运行状态（唤醒）
        限时等待状态（TIMED_WAITING），限时等待是等待一段时间，时间到了之后就会转换为可运行状态
            Thread.sleep、Thread.join、Object.wait(ms)、LockSupport.parkNonos、LockSupport.parkUntil 让线程进入限时等待状态
        终止状态（TERMINATED），线程的任务执行完毕或任务执行遇到异常时，线程就处于终止状态
        
#### 线程调度

        JMM（Java Memory Model）堆内存和方法区是线程共享的，所有变量都存储在主内存
        原子性，共享变量造成
        高速缓存，处理器执行内存读写操作时，不是直接与主内存，而是通过高速缓存进行的，高速缓存类似散列表，key是内存地址，value可以是内存数据的副本，也可以是准备写入内存的数据
        多线程并发是指多个线程轮流获取CPU试用权，分别执行各自的任务
        线程调度由JVM负责，按照特定的机制为多个线程分配CPU时间片
        线程调度模型分为 分时调度模型和抢占式调度模型：
            分时调度模型，让所有线程轮流获取CPU使用权，平均分配每个线程占用CPU的时间片
            抢占式调度模型，JVM采用，先让优先级高的线程占用CPU，若优先级一样，随机选择一个线程，要想干预线程的调度过程，最简单就是设定优先级

#### 线程的安全性

        竞态、原子性、可见性、有序性
        竞态：
            多个线程之间对一个或多个共享可变对象交错操作时，有可能导致数据异常
            多线程中一样的输入在不同的时间有不一样的输出，这种计算结果的正确性与时间有关的现象就是竞态
            竞态伴随着共享变量的 脏数据（线程读到一个过时的数据）、丢失更新（一个线程对数据做的更新，没有被其他线程读取到）
        原子性：
            原子，不可分割的，对共享变量访问的操作，若改操作从其执行线程以外的任意线程看来是不可分割的，那个该操作就是原子操作，称该操作具有原子性（Atomicity）
            访问同一组共享变量的原子操作是不能被交错的
            没有原子性，可能会导致脏数据和丢失更新
        可见性：
            一个线程对某个共享变量进行更新后，后续访问该变量的线程可能无法立刻读取到更新的结果，甚至永远也无法读取到，这就是可见性
            可见性是指一个线程对共享变量的更新，对于其他读取该变量的线程是否可见
            可见性描述的是一个线程对共享变量的更新。对于另一个线程是否可见，保证可见性意味着一个线程可以读取到对应共享变量的新值
            同时保证可见性和原子性才能确保一个线程能正确地看到其他线程对共享变量做的更新
        有序性：
            有序性是指一个处理器在为一个线程执行的内存访问操作，对应另一个处理器上运行的线程来看是否是乱序的
            指令重排序（Reordering）是处理器和编译器对代码做的一种优化，可以在不影响单线程程序正确性的情况下提升程序的性能，但是它对多线程程序的正确性产生影响，导致线程问题
            处理器的乱序执行，哪条执行就绪就先执行哪条指令
            
#### 线程安全

        保证原子性、可见性和有序性
        使用锁和原子类型，锁分为内部锁、显式锁、读写锁、轻量级锁（volatile）4种
        锁的5个特点：
            临界区，持有锁的线程获得锁后和释放锁前执行的代码叫做临界区（Critical Section）
            排他性，锁具有排他性，能够保障一个共享变量在任一时刻只能被一个线程访问，这就保证了临界区代码一次只能被一个线程执行，临界区的操作具有不可分割性，保证了原子性
            串行，锁相当于把多个线程对共享变量的操作从并发改为串行
            三种保障，锁包含共享变量实现线程安全，作用包括保障原子性、可见性和有序性
            调度策略，锁的调度策略分为公平策略和非公平策略，对应的锁就叫公平锁和非公平锁
                公平锁会在加锁前查看是否有等待的线程，有的话会优先处理排在前面的线程
                公平锁以增加上下文切换为代价，保障了锁调度的公平性，增加了线程暂停和唤醒的可能性
        锁的2个问题：
            锁泄漏，是指一个线程获得锁后，由于程序错误导致锁一直无法被释放，导致其他线程一直无法获得该锁
            活跃性问题，锁泄漏会导致活跃性问题，包括死锁、锁死等
        
        内部锁：
            synchronized关键字实现内部锁，即同步方法和同步代码块
            监视器锁，synchronized是通过监视器（monitor）来实现的，所以内部锁也叫监视器锁
            自动获取/释放，线程对同步代码块锁的申请和释放由JVM内部实施，线程在进入同步代码块前会自动获取锁，退出同步代码块时自动释放锁，这也是同步代码块被称为内部锁的原因
            锁定方法/类/对象，synchronized关键字可以修饰方法，锁住特定类和特定对象
            临界区，同步代码块就是内部锁的临界区，线程在执行临界区代码前必须持有该临界区的内部锁
            锁句柄，内部锁锁的对象就叫锁句柄，锁句柄通常由 private final 修饰，因为锁句柄一旦改变，会导致执行同一个同步代码块的多个线程实际上用的是不同的锁
            不会泄漏，内部锁不会导致锁泄漏，编译器把同步代码块中可能抛出的异常做了特殊处理，这样临界区的代码出了异常也不会妨碍锁的释放
            非公平锁，使用的是非公平策略，不会增加上下文切换开销
        显式锁：
            Explict Lock，是Lock接口的实例，Lock接口对显式锁进行了抽象，ReentrantLock是它的实现类
            可重入，显式锁是可重入锁，一个线程持有锁后，能再次成功申请这个锁
            手动获取/释放，与内部锁的区别在于 需要自己释放和获取锁，为避免锁泄漏，要在finally块中释放锁
            临界区，lock、unlock方法之间的代码就是显式锁的临界区
            公平/非公平锁，允许自己选择锁调度策略，fair为true说明是公平锁；公平锁的开销比非公平锁大，所以ReentrantLock的默认调度策略是非公平锁
            lock()，获取锁，获取失败 时线程会处于阻塞状态
            tryLock()，获取锁，成功返回true，获取失败返回false，不会处于阻塞状态
            tryLock(time, unit)，获取锁，成功返回true，在指定时间内未获取到锁 返回false，在指定时间内处于阻塞状态，可中断
            lockInterruptibly()，获取锁，可中断
        内部锁与显式锁的区别：
            灵活性，内部锁是基于代码的锁，锁的申请、释放只能在一个方法内执行，缺乏灵活性，显式锁是基于对象的锁，锁的申请和释放可以在不同的方法中执行，灵活性更高
            锁调度策略，内部锁只能是非公平锁，显式锁可以自己选择调度策略
            便利性，内部锁简单易用，不会出现锁泄漏的情况，显式锁需要自己手动获取/释放锁，使用不当会导致锁泄漏
            阻塞，如果持有内部锁的线程一直不释放这个锁，那其他申请这个锁的线程只能一直等待，显式锁的tryLock方法 返回获取锁的结果，不会导致线程处于阻塞状态
            适用场景，多个线程持有锁的平均时间不长的情况下可以使用内部锁，否则平均时间较长的情况下可以使用显式锁（公平锁）
        读写锁：
            锁的排他性使得多个线程无法以线程安全的方式在同一时刻读取共享变量，这不利于提高系统的并发性
            读写锁ReadWriteLock接口的实现类是ReentrantReadWriteLock
            只读取共享变量的线程叫读线程，只更新共享变量的线程叫写线程
            读写锁是一种改进的排它锁，也叫共享/排他（Shared/Exclusive）锁
            读锁共享，读写锁允许多个线程同时读取共享变量，读线程访问共享变量时，必须持有对应的读锁，读锁可以被多个线程持有
            写锁排他，读写锁一次只允许一个线程更新共享变量，写线程访问共享变量时，必须持有对应的写锁，写锁在任一时刻只能被一个线程持有
            可以降级，读写锁是一个支持降级的可重入锁，即一个线程持有写锁的情况下，可以继续获取对应的读锁；这样可以在修改变量后，在其他地方读取该变量，执行其他操作
            不能升级，读写锁不支持升级，读线程只有释放读锁才能申请写锁
            三种保障，读写锁允许多个线程读取共享变量，但是由于写锁的特性，它同样能保障原子性、可见性和有序性
            适用场景，读写锁会带来额外开销，在 读操作比写操作频繁很多、读取共享变量的线程持有锁的时间较长 满足这两个条件下读写锁才使用
            
            多个线程是可以同时获取读锁而不需要阻塞等待；一个获取写锁的线程是可以在释放写锁之前再次获取读锁的，这就是锁降级。
            一个线程获取了读锁，那么其他的线程要获取写锁 需要等待；同样的，一个线程获取了写锁，另外的想要获取读锁或者写锁都需要阻塞等待
            
        轻量级锁（volatile）：
            volatile关键字用于修饰共享变量
            易变化，volatile用于修饰容易发生变化的变量，不稳定 指的是对这种变量的读写操作要从高速缓存或主内存中读取，而不会分配到寄存器中
            开销，比锁低（volatile变量的读写不会导致上下文切换），比普通变量高（volatile变量的值每次都要从高速缓存或主内存中读取，无法被暂存到寄存器中）
            释放/存储屏障，对volatile变量的写操作，JVM在该操作前插入一个释放屏障，操作后插入一个存储屏障，存储屏障具有冲刷处理器缓存的作用，插入存储屏障，能让该存储屏障前的所有操作结果对其他处理器来说是同步的
            加载/获取屏障，对volatile变量的读操作，JVM在该操作前插入一个加载屏障，操作后插入一个获取屏障，加载屏障通过冲刷处理器缓存，使线程所在的处理器将其他处理器对该共享变量做的更新同步到该处理器的高速缓存中
            保证有序性，volatile能禁止指令重排序，保证操作的有序性
            保证可见性，加载屏障和存储屏障配合在一起，能让写线程对volatile变量的写操作对读线程可见，从而保证可见性
            原子性，对于long/double型变量，volatile能保证读写操作的原子性；对于其他变量只能保证写操作的原子性
            
            如果 volatile 变量写操作前涉及共享变量，竞态仍然可能发生，因为共享变量赋值给 volatile 变量时，其他线程可能已经更新了该共享变量的值
            
        原子类型（atomic）：
            原子类，不需要加锁也能保证线程安全，原子类是通过UnSafe类中的CAS指令从硬件层面来实现线程安全的
            AtomicInteger、AtomicBoolean、AtomicReference、AtomicReferenceFieldUpdater等
            AtomicReference的基本用法，compareAndSet、updateAndGet
            AtomicReferenceFieldUpdater的基本用法，通常作为类的静态成员使用，compareAndSet、updateAndGet 等等
            使用AtomicReference要比AtomicReferenceFieldUpdater多创建一个对象，  32位机器对象头占12个字节，成员占4个字节，共16字节；64位机器未启动指针压缩时，对象头占16个字节，成员占8字节，共24字节；启动时相同
            在原子类型实例较少时使用AtomicReference，否则使用 AtomicReferenceFieldUpdater
        锁的使用技巧：
            长锁不如短锁，尽量只对必要部分加锁
            大锁不如小锁，尽可能对加锁的对象拆分
            公锁不如私锁，尽可能把锁的逻辑放到私有代码中，外部加锁使用不当可能会导致死锁
            嵌套锁不如扁平锁，避免锁嵌套
            分离读写锁，尽可能将读锁和写锁分离
            粗化高频锁，合并处理频繁而且过短的锁，锁都有开销
            消除无用锁，尽可能不加锁，或使用volatile代替
    
#### 线程协作

        线程间常见的协作方式有 等待和中断
        当一个线程需要等待另一个线程中的操作结束时，就涉及到等待型线程协作
        等待型线程协作方式有 join、 wait/notify、await/signal、await/countDown、CyclicBarrier
        join，让一个线程等待另一个线程执行结束后再继续执行，内部是通过wait()实现的，不断判断调用了join方法的线程使用还存活，是的话继续等待
        wait/notify，用于实现等待和通知；  notifyAll等等
            JVM会给每个对象维护一个入口集（Entry Set）和一个等待集（Wait Set）
            入口集用于存储申请该对象内部锁的线程，等待集用于存储对象上的等待线程
            wait方法将当前线程暂停，释放内部锁时，会将当前线程存入该方法所属对象的等待集中
            notify方法，会让该对象的等待集中的任意一个线程唤醒，被唤醒的线程继续留在等待集中，直到该线程再次持有对应的内部锁时，wait方法就会把当前线程从对象的等待集中移除
            添加当前线程到等待集、暂停当前线程、释放锁以及把唤醒后的线程从对象的等待集中移除，都是在wait方法中实现的
            wait方法的native代码中，会判断线程是否持有当前对象的内部锁，没有会报异常，需要在同步代码块中执行wait方法
        await/signal，wait/notify过于底层，还有过早唤醒和无法区分wait返回是由于等待超时还是被通知线程唤醒
            Condition接口，使用Condition可以实现等待/通知，且不存在上述问题；await/signal/signalAll相当于 object的 wait/notify/notifyAll；通过Lock.newCondition获得Condition实例
            持有锁，wait/notify需要线程持有所属对象的内部锁，await/signal要求线程持有Condition实例的显式锁
            等待队列，Condition实例也叫条件变量或条件队列，Condition实例内部维护一个用于存储等待线程的等待队列，相当于Object中的等待集
            循环语句，对于保护条件的判断和await方法的调用，要放在循环语句中
            引导区内，循环语句和执行目标动作要放在同一个显式锁引导的临界区内，这是为了避免欺骗性唤醒和信号丢失的问题
            {
                lock.lock();
                condition.await();
                finally {
                    lock.unlock();
                }
            }
            {
                lock.lock();
                condition.signal();
                finally {
                    lock.unlock();
                }
            }
        await/countDown，join实现的是等待线程执行结束，CountDownLatch可以实现等待一个特定的操作执行结束，不需要整个线程执行结束
            先决操作，CountDownLatch可以实现一个或多个线程等待其他线程完成一组特定的操作后才继续运行，这组线程就叫先决操作
            先决操作数，CountDownLatch内部维护一个计算未完成先决操作数的count值，countDown时减1，未完成先决操作数count是在构造函数中设置的，不能小于0
            一次性，计数器的值为0时，后续再调用await时不会再让执行线程进入等待状态，级CountDownLatch是一次性动作
            不用加锁，CountDownLatch内部封装了对count值的等待和通知逻辑，使用CountDownLatch实现等待/通知是不用加锁
            await()，让线程进入等待状态，count值为0时，表示需要等待的先决操作已经完成
            countDown()，使count值减1，在count值为0时，会唤醒对应的等待线程
            内部使用AQS、原子类
    
    让线程停止：
        stop()，已被弃用，不安全
        interrupt()，线程的休眠状态可以被中断，中断后就会收到一个中断异常，可以在捕捉到中断异常后释放锁已经其他资源等
            interrupt不能百分百中断任务，比如在while循环中捕捉异常，可以通过interrupted()、isInterrupted()获取线程的中断状态使退出循环
            interrupted()，静态方法，会重置中断状态，使中断状态为false
            isInterrupted()，非静态方法，不会重置中断状态，两者本质上都是通过Native层布尔标志位判断
        布尔标志位，在Java层设置一个boolean值，让线程共享
                想取消某个任务时，就在外部把标志位改为true
                用volatile修饰这个值（可见性问题）
                sleep时，使用interrupt中断任务，其他时候使用布尔标志位
    
#### 线程使用准则

        严禁直接创建线程
        提供基础线程池供各个业务线使用
        选择合适的异步方式，如：长时间运行，但优先级较低的任务，可以使用HanderThread；执行定时任务，更适合使用线程池
        线程必须命名
        重视优先级设置，抢占式调度模型，高优先级能先占用CPU，设置方式：Process.setThreadPriority(priority)，值越小优先级越高，取值范围 -20~19
        